{-# OPTIONS_GHC -w #-}
{-# LANGUAGE GADTs, KindSignatures, DataKinds #-}
module Gramatyka.AbsLatte (Tree(..), Program, TopDef, Arg, ClsBowel, Block, Stmt, Item, Type, Expr, AddOp, MulOp, RelOp, Ident, johnMajorEq, module Gramatyka.ComposOp) where

import Gramatyka.ComposOp

import Data.Monoid (mappend)


-- Haskell module generated by the BNF converter

data Tag = Program_ | TopDef_ | Arg_ | ClsBowel_ | Block_ | Stmt_ | Item_ | Type_ | Expr_ | AddOp_ | MulOp_ | RelOp_ | Ident_
type Program = Tree Program_
type TopDef = Tree TopDef_
type Arg = Tree Arg_
type ClsBowel = Tree ClsBowel_
type Block = Tree Block_
type Stmt = Tree Stmt_
type Item = Tree Item_
type Type = Tree Type_
type Expr = Tree Expr_
type AddOp = Tree AddOp_
type MulOp = Tree MulOp_
type RelOp = Tree RelOp_
type Ident = Tree Ident_

data Tree :: Tag -> * where
    Prgm :: [TopDef] -> Tree Program_
    FnDef :: Type -> Ident -> [Arg] -> Block -> Tree TopDef_
    ClsDef :: Ident -> [ClsBowel] -> Tree TopDef_
    ClsExtDef :: Ident -> Ident -> [ClsBowel] -> Tree TopDef_
    Argument :: Type -> Ident -> Tree Arg_
    MemberDef :: Type -> [Item] -> Tree ClsBowel_
    MethodDef :: Type -> Ident -> [Arg] -> Block -> Tree ClsBowel_
    Blk :: [Stmt] -> Tree Block_
    Empty :: Tree Stmt_
    BStmt :: Block -> Tree Stmt_
    Decl :: Type -> [Item] -> Tree Stmt_
    Ass :: Expr -> Expr -> Tree Stmt_
    Incr :: Ident -> Tree Stmt_
    Decr :: Ident -> Tree Stmt_
    Ret :: Expr -> Tree Stmt_
    VRet :: Tree Stmt_
    Cond :: Expr -> Stmt -> Tree Stmt_
    CondElse :: Expr -> Stmt -> Stmt -> Tree Stmt_
    While :: Expr -> Stmt -> Tree Stmt_
    SExp :: Expr -> Tree Stmt_
    NoInit :: Ident -> Tree Item_
    Init :: Ident -> Expr -> Tree Item_
    IdentType :: Ident -> Tree Type_
    Void :: Tree Type_
    Fun :: Type -> [Type] -> Tree Type_
    ECast :: Ident -> Tree Expr_
    EVar :: Ident -> Tree Expr_
    EMember :: Expr -> Ident -> Tree Expr_
    EConstr :: Ident -> Tree Expr_
    ELitInt :: Integer -> Tree Expr_
    ELitTrue :: Tree Expr_
    ELitFalse :: Tree Expr_
    EMethApp :: Expr -> Ident -> [Expr] -> Tree Expr_
    EApp :: Ident -> [Expr] -> Tree Expr_
    EString :: String -> Tree Expr_
    Neg :: Expr -> Tree Expr_
    Not :: Expr -> Tree Expr_
    EMul :: Expr -> MulOp -> Expr -> Tree Expr_
    EAdd :: Expr -> AddOp -> Expr -> Tree Expr_
    ERel :: Expr -> RelOp -> Expr -> Tree Expr_
    EAnd :: Expr -> Expr -> Tree Expr_
    EOr :: Expr -> Expr -> Tree Expr_
    Plus :: Tree AddOp_
    Minus :: Tree AddOp_
    Times :: Tree MulOp_
    Div :: Tree MulOp_
    Mod :: Tree MulOp_
    LTH :: Tree RelOp_
    LE :: Tree RelOp_
    GTH :: Tree RelOp_
    GE :: Tree RelOp_
    EQU :: Tree RelOp_
    NE :: Tree RelOp_
    Ident :: String -> Tree Ident_

instance Compos Tree where
  compos r a f t = case t of
      Prgm topdefs -> r Prgm `a` foldr (a . a (r (:)) . f) (r []) topdefs
      FnDef type' i args block -> r FnDef `a` f type' `a` f i `a` foldr (a . a (r (:)) . f) (r []) args `a` f block
      ClsDef i clsbowels -> r ClsDef `a` f i `a` foldr (a . a (r (:)) . f) (r []) clsbowels
      ClsExtDef i0 i1 clsbowels2 -> r ClsExtDef `a` f i0 `a` f i1 `a` foldr (a . a (r (:)) . f) (r []) clsbowels2
      Argument type' i -> r Argument `a` f type' `a` f i
      MemberDef type' items -> r MemberDef `a` f type' `a` foldr (a . a (r (:)) . f) (r []) items
      MethodDef type' i args block -> r MethodDef `a` f type' `a` f i `a` foldr (a . a (r (:)) . f) (r []) args `a` f block
      Blk stmts -> r Blk `a` foldr (a . a (r (:)) . f) (r []) stmts
      BStmt block -> r BStmt `a` f block
      Decl type' items -> r Decl `a` f type' `a` foldr (a . a (r (:)) . f) (r []) items
      Ass expr0 expr1 -> r Ass `a` f expr0 `a` f expr1
      Incr i -> r Incr `a` f i
      Decr i -> r Decr `a` f i
      Ret expr -> r Ret `a` f expr
      Cond expr stmt -> r Cond `a` f expr `a` f stmt
      CondElse expr stmt0 stmt1 -> r CondElse `a` f expr `a` f stmt0 `a` f stmt1
      While expr stmt -> r While `a` f expr `a` f stmt
      SExp expr -> r SExp `a` f expr
      NoInit i -> r NoInit `a` f i
      Init i expr -> r Init `a` f i `a` f expr
      IdentType i -> r IdentType `a` f i
      Fun type' types -> r Fun `a` f type' `a` foldr (a . a (r (:)) . f) (r []) types
      ECast i -> r ECast `a` f i
      EVar i -> r EVar `a` f i
      EMember expr i -> r EMember `a` f expr `a` f i
      EConstr i -> r EConstr `a` f i
      EMethApp expr i exprs -> r EMethApp `a` f expr `a` f i `a` foldr (a . a (r (:)) . f) (r []) exprs
      EApp i exprs -> r EApp `a` f i `a` foldr (a . a (r (:)) . f) (r []) exprs
      Neg expr -> r Neg `a` f expr
      Not expr -> r Not `a` f expr
      EMul expr0 mulop1 expr2 -> r EMul `a` f expr0 `a` f mulop1 `a` f expr2
      EAdd expr0 addop1 expr2 -> r EAdd `a` f expr0 `a` f addop1 `a` f expr2
      ERel expr0 relop1 expr2 -> r ERel `a` f expr0 `a` f relop1 `a` f expr2
      EAnd expr0 expr1 -> r EAnd `a` f expr0 `a` f expr1
      EOr expr0 expr1 -> r EOr `a` f expr0 `a` f expr1
      _ -> r t

instance Show (Tree c) where
  showsPrec n t = case t of
    Prgm topdefs -> opar n . showString "Prgm" . showChar ' ' . showsPrec 1 topdefs . cpar n
    FnDef type' i args block -> opar n . showString "FnDef" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 i . showChar ' ' . showsPrec 1 args . showChar ' ' . showsPrec 1 block . cpar n
    ClsDef i clsbowels -> opar n . showString "ClsDef" . showChar ' ' . showsPrec 1 i . showChar ' ' . showsPrec 1 clsbowels . cpar n
    ClsExtDef i0 i1 clsbowels2 -> opar n . showString "ClsExtDef" . showChar ' ' . showsPrec 1 i0 . showChar ' ' . showsPrec 1 i1 . showChar ' ' . showsPrec 1 clsbowels2 . cpar n
    Argument type' i -> opar n . showString "Argument" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 i . cpar n
    MemberDef type' items -> opar n . showString "MemberDef" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 items . cpar n
    MethodDef type' i args block -> opar n . showString "MethodDef" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 i . showChar ' ' . showsPrec 1 args . showChar ' ' . showsPrec 1 block . cpar n
    Blk stmts -> opar n . showString "Blk" . showChar ' ' . showsPrec 1 stmts . cpar n
    Empty -> showString "Empty"
    BStmt block -> opar n . showString "BStmt" . showChar ' ' . showsPrec 1 block . cpar n
    Decl type' items -> opar n . showString "Decl" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 items . cpar n
    Ass expr0 expr1 -> opar n . showString "Ass" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 expr1 . cpar n
    Incr i -> opar n . showString "Incr" . showChar ' ' . showsPrec 1 i . cpar n
    Decr i -> opar n . showString "Decr" . showChar ' ' . showsPrec 1 i . cpar n
    Ret expr -> opar n . showString "Ret" . showChar ' ' . showsPrec 1 expr . cpar n
    VRet -> showString "VRet"
    Cond expr stmt -> opar n . showString "Cond" . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 stmt . cpar n
    CondElse expr stmt0 stmt1 -> opar n . showString "CondElse" . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 stmt0 . showChar ' ' . showsPrec 1 stmt1 . cpar n
    While expr stmt -> opar n . showString "While" . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 stmt . cpar n
    SExp expr -> opar n . showString "SExp" . showChar ' ' . showsPrec 1 expr . cpar n
    NoInit i -> opar n . showString "NoInit" . showChar ' ' . showsPrec 1 i . cpar n
    Init i expr -> opar n . showString "Init" . showChar ' ' . showsPrec 1 i . showChar ' ' . showsPrec 1 expr . cpar n
    IdentType i -> opar n . showString "IdentType" . showChar ' ' . showsPrec 1 i . cpar n
    Void -> showString "Void"
    Fun type' types -> opar n . showString "Fun" . showChar ' ' . showsPrec 1 type' . showChar ' ' . showsPrec 1 types . cpar n
    ECast i -> opar n . showString "ECast" . showChar ' ' . showsPrec 1 i . cpar n
    EVar i -> opar n . showString "EVar" . showChar ' ' . showsPrec 1 i . cpar n
    EMember expr i -> opar n . showString "EMember" . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 i . cpar n
    EConstr i -> opar n . showString "EConstr" . showChar ' ' . showsPrec 1 i . cpar n
    ELitInt n -> opar n . showString "ELitInt" . showChar ' ' . showsPrec 1 n . cpar n
    ELitTrue -> showString "ELitTrue"
    ELitFalse -> showString "ELitFalse"
    EMethApp expr i exprs -> opar n . showString "EMethApp" . showChar ' ' . showsPrec 1 expr . showChar ' ' . showsPrec 1 i . showChar ' ' . showsPrec 1 exprs . cpar n
    EApp i exprs -> opar n . showString "EApp" . showChar ' ' . showsPrec 1 i . showChar ' ' . showsPrec 1 exprs . cpar n
    EString str -> opar n . showString "EString" . showChar ' ' . showsPrec 1 str . cpar n
    Neg expr -> opar n . showString "Neg" . showChar ' ' . showsPrec 1 expr . cpar n
    Not expr -> opar n . showString "Not" . showChar ' ' . showsPrec 1 expr . cpar n
    EMul expr0 mulop1 expr2 -> opar n . showString "EMul" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 mulop1 . showChar ' ' . showsPrec 1 expr2 . cpar n
    EAdd expr0 addop1 expr2 -> opar n . showString "EAdd" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 addop1 . showChar ' ' . showsPrec 1 expr2 . cpar n
    ERel expr0 relop1 expr2 -> opar n . showString "ERel" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 relop1 . showChar ' ' . showsPrec 1 expr2 . cpar n
    EAnd expr0 expr1 -> opar n . showString "EAnd" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 expr1 . cpar n
    EOr expr0 expr1 -> opar n . showString "EOr" . showChar ' ' . showsPrec 1 expr0 . showChar ' ' . showsPrec 1 expr1 . cpar n
    Plus -> showString "Plus"
    Minus -> showString "Minus"
    Times -> showString "Times"
    Div -> showString "Div"
    Mod -> showString "Mod"
    LTH -> showString "LTH"
    LE -> showString "LE"
    GTH -> showString "GTH"
    GE -> showString "GE"
    EQU -> showString "EQU"
    NE -> showString "NE"
    Ident str -> opar n . showString "Ident" . showChar ' ' . showsPrec 1 str . cpar n
   where opar n = if n > 0 then showChar '(' else id
         cpar n = if n > 0 then showChar ')' else id

instance Eq (Tree c) where (==) = johnMajorEq

johnMajorEq :: Tree a -> Tree b -> Bool
johnMajorEq (Prgm topdefs) (Prgm topdefs_) = topdefs == topdefs_
johnMajorEq (FnDef type' i args block) (FnDef type'_ i_ args_ block_) = type' == type'_ && i == i_ && args == args_ && block == block_
johnMajorEq (ClsDef i clsbowels) (ClsDef i_ clsbowels_) = i == i_ && clsbowels == clsbowels_
johnMajorEq (ClsExtDef i0 i1 clsbowels2) (ClsExtDef i0_ i1_ clsbowels2_) = i0 == i0_ && i1 == i1_ && clsbowels2 == clsbowels2_
johnMajorEq (Argument type' i) (Argument type'_ i_) = type' == type'_ && i == i_
johnMajorEq (MemberDef type' items) (MemberDef type'_ items_) = type' == type'_ && items == items_
johnMajorEq (MethodDef type' i args block) (MethodDef type'_ i_ args_ block_) = type' == type'_ && i == i_ && args == args_ && block == block_
johnMajorEq (Blk stmts) (Blk stmts_) = stmts == stmts_
johnMajorEq Empty Empty = True
johnMajorEq (BStmt block) (BStmt block_) = block == block_
johnMajorEq (Decl type' items) (Decl type'_ items_) = type' == type'_ && items == items_
johnMajorEq (Ass expr0 expr1) (Ass expr0_ expr1_) = expr0 == expr0_ && expr1 == expr1_
johnMajorEq (Incr i) (Incr i_) = i == i_
johnMajorEq (Decr i) (Decr i_) = i == i_
johnMajorEq (Ret expr) (Ret expr_) = expr == expr_
johnMajorEq VRet VRet = True
johnMajorEq (Cond expr stmt) (Cond expr_ stmt_) = expr == expr_ && stmt == stmt_
johnMajorEq (CondElse expr stmt0 stmt1) (CondElse expr_ stmt0_ stmt1_) = expr == expr_ && stmt0 == stmt0_ && stmt1 == stmt1_
johnMajorEq (While expr stmt) (While expr_ stmt_) = expr == expr_ && stmt == stmt_
johnMajorEq (SExp expr) (SExp expr_) = expr == expr_
johnMajorEq (NoInit i) (NoInit i_) = i == i_
johnMajorEq (Init i expr) (Init i_ expr_) = i == i_ && expr == expr_
johnMajorEq (IdentType i) (IdentType i_) = i == i_
johnMajorEq Void Void = True
johnMajorEq (Fun type' types) (Fun type'_ types_) = type' == type'_ && types == types_
johnMajorEq (ECast i) (ECast i_) = i == i_
johnMajorEq (EVar i) (EVar i_) = i == i_
johnMajorEq (EMember expr i) (EMember expr_ i_) = expr == expr_ && i == i_
johnMajorEq (EConstr i) (EConstr i_) = i == i_
johnMajorEq (ELitInt n) (ELitInt n_) = n == n_
johnMajorEq ELitTrue ELitTrue = True
johnMajorEq ELitFalse ELitFalse = True
johnMajorEq (EMethApp expr i exprs) (EMethApp expr_ i_ exprs_) = expr == expr_ && i == i_ && exprs == exprs_
johnMajorEq (EApp i exprs) (EApp i_ exprs_) = i == i_ && exprs == exprs_
johnMajorEq (EString str) (EString str_) = str == str_
johnMajorEq (Neg expr) (Neg expr_) = expr == expr_
johnMajorEq (Not expr) (Not expr_) = expr == expr_
johnMajorEq (EMul expr0 mulop1 expr2) (EMul expr0_ mulop1_ expr2_) = expr0 == expr0_ && mulop1 == mulop1_ && expr2 == expr2_
johnMajorEq (EAdd expr0 addop1 expr2) (EAdd expr0_ addop1_ expr2_) = expr0 == expr0_ && addop1 == addop1_ && expr2 == expr2_
johnMajorEq (ERel expr0 relop1 expr2) (ERel expr0_ relop1_ expr2_) = expr0 == expr0_ && relop1 == relop1_ && expr2 == expr2_
johnMajorEq (EAnd expr0 expr1) (EAnd expr0_ expr1_) = expr0 == expr0_ && expr1 == expr1_
johnMajorEq (EOr expr0 expr1) (EOr expr0_ expr1_) = expr0 == expr0_ && expr1 == expr1_
johnMajorEq Plus Plus = True
johnMajorEq Minus Minus = True
johnMajorEq Times Times = True
johnMajorEq Div Div = True
johnMajorEq Mod Mod = True
johnMajorEq LTH LTH = True
johnMajorEq LE LE = True
johnMajorEq GTH GTH = True
johnMajorEq GE GE = True
johnMajorEq EQU EQU = True
johnMajorEq NE NE = True
johnMajorEq (Ident str) (Ident str_) = str == str_
johnMajorEq _ _ = False

instance Ord (Tree c) where
  compare x y = compare (index x) (index y) `mappend` compareSame x y
index :: Tree c -> Int
index (Prgm _) = 0
index (FnDef _ _ _ _) = 1
index (ClsDef _ _) = 2
index (ClsExtDef _ _ _) = 3
index (Argument _ _) = 4
index (MemberDef _ _) = 5
index (MethodDef _ _ _ _) = 6
index (Blk _) = 7
index (Empty ) = 8
index (BStmt _) = 9
index (Decl _ _) = 10
index (Ass _ _) = 11
index (Incr _) = 12
index (Decr _) = 13
index (Ret _) = 14
index (VRet ) = 15
index (Cond _ _) = 16
index (CondElse _ _ _) = 17
index (While _ _) = 18
index (SExp _) = 19
index (NoInit _) = 20
index (Init _ _) = 21
index (IdentType _) = 22
index (Void ) = 23
index (Fun _ _) = 24
index (ECast _) = 25
index (EVar _) = 26
index (EMember _ _) = 27
index (EConstr _) = 28
index (ELitInt _) = 29
index (ELitTrue ) = 30
index (ELitFalse ) = 31
index (EMethApp _ _ _) = 32
index (EApp _ _) = 33
index (EString _) = 34
index (Neg _) = 35
index (Not _) = 36
index (EMul _ _ _) = 37
index (EAdd _ _ _) = 38
index (ERel _ _ _) = 39
index (EAnd _ _) = 40
index (EOr _ _) = 41
index (Plus ) = 42
index (Minus ) = 43
index (Times ) = 44
index (Div ) = 45
index (Mod ) = 46
index (LTH ) = 47
index (LE ) = 48
index (GTH ) = 49
index (GE ) = 50
index (EQU ) = 51
index (NE ) = 52
index (Ident _) = 53
compareSame :: Tree c -> Tree c -> Ordering
compareSame (Prgm topdefs) (Prgm topdefs_) = compare topdefs topdefs_
compareSame (FnDef type' i args block) (FnDef type'_ i_ args_ block_) = mappend (compare type' type'_) (mappend (compare i i_) (mappend (compare args args_) (compare block block_)))
compareSame (ClsDef i clsbowels) (ClsDef i_ clsbowels_) = mappend (compare i i_) (compare clsbowels clsbowels_)
compareSame (ClsExtDef i0 i1 clsbowels2) (ClsExtDef i0_ i1_ clsbowels2_) = mappend (compare i0 i0_) (mappend (compare i1 i1_) (compare clsbowels2 clsbowels2_))
compareSame (Argument type' i) (Argument type'_ i_) = mappend (compare type' type'_) (compare i i_)
compareSame (MemberDef type' items) (MemberDef type'_ items_) = mappend (compare type' type'_) (compare items items_)
compareSame (MethodDef type' i args block) (MethodDef type'_ i_ args_ block_) = mappend (compare type' type'_) (mappend (compare i i_) (mappend (compare args args_) (compare block block_)))
compareSame (Blk stmts) (Blk stmts_) = compare stmts stmts_
compareSame Empty Empty = EQ
compareSame (BStmt block) (BStmt block_) = compare block block_
compareSame (Decl type' items) (Decl type'_ items_) = mappend (compare type' type'_) (compare items items_)
compareSame (Ass expr0 expr1) (Ass expr0_ expr1_) = mappend (compare expr0 expr0_) (compare expr1 expr1_)
compareSame (Incr i) (Incr i_) = compare i i_
compareSame (Decr i) (Decr i_) = compare i i_
compareSame (Ret expr) (Ret expr_) = compare expr expr_
compareSame VRet VRet = EQ
compareSame (Cond expr stmt) (Cond expr_ stmt_) = mappend (compare expr expr_) (compare stmt stmt_)
compareSame (CondElse expr stmt0 stmt1) (CondElse expr_ stmt0_ stmt1_) = mappend (compare expr expr_) (mappend (compare stmt0 stmt0_) (compare stmt1 stmt1_))
compareSame (While expr stmt) (While expr_ stmt_) = mappend (compare expr expr_) (compare stmt stmt_)
compareSame (SExp expr) (SExp expr_) = compare expr expr_
compareSame (NoInit i) (NoInit i_) = compare i i_
compareSame (Init i expr) (Init i_ expr_) = mappend (compare i i_) (compare expr expr_)
compareSame (IdentType i) (IdentType i_) = compare i i_
compareSame Void Void = EQ
compareSame (Fun type' types) (Fun type'_ types_) = mappend (compare type' type'_) (compare types types_)
compareSame (ECast i) (ECast i_) = compare i i_
compareSame (EVar i) (EVar i_) = compare i i_
compareSame (EMember expr i) (EMember expr_ i_) = mappend (compare expr expr_) (compare i i_)
compareSame (EConstr i) (EConstr i_) = compare i i_
compareSame (ELitInt n) (ELitInt n_) = compare n n_
compareSame ELitTrue ELitTrue = EQ
compareSame ELitFalse ELitFalse = EQ
compareSame (EMethApp expr i exprs) (EMethApp expr_ i_ exprs_) = mappend (compare expr expr_) (mappend (compare i i_) (compare exprs exprs_))
compareSame (EApp i exprs) (EApp i_ exprs_) = mappend (compare i i_) (compare exprs exprs_)
compareSame (EString str) (EString str_) = compare str str_
compareSame (Neg expr) (Neg expr_) = compare expr expr_
compareSame (Not expr) (Not expr_) = compare expr expr_
compareSame (EMul expr0 mulop1 expr2) (EMul expr0_ mulop1_ expr2_) = mappend (compare expr0 expr0_) (mappend (compare mulop1 mulop1_) (compare expr2 expr2_))
compareSame (EAdd expr0 addop1 expr2) (EAdd expr0_ addop1_ expr2_) = mappend (compare expr0 expr0_) (mappend (compare addop1 addop1_) (compare expr2 expr2_))
compareSame (ERel expr0 relop1 expr2) (ERel expr0_ relop1_ expr2_) = mappend (compare expr0 expr0_) (mappend (compare relop1 relop1_) (compare expr2 expr2_))
compareSame (EAnd expr0 expr1) (EAnd expr0_ expr1_) = mappend (compare expr0 expr0_) (compare expr1 expr1_)
compareSame (EOr expr0 expr1) (EOr expr0_ expr1_) = mappend (compare expr0 expr0_) (compare expr1 expr1_)
compareSame Plus Plus = EQ
compareSame Minus Minus = EQ
compareSame Times Times = EQ
compareSame Div Div = EQ
compareSame Mod Mod = EQ
compareSame LTH LTH = EQ
compareSame LE LE = EQ
compareSame GTH GTH = EQ
compareSame GE GE = EQ
compareSame EQU EQU = EQ
compareSame NE NE = EQ
compareSame (Ident str) (Ident str_) = compare str str_
compareSame x y = error "BNFC error:" compareSame
